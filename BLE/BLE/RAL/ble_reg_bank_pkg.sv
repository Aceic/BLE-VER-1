//----------------------------------------------------------------------
//   THIS IS AUTOMATICALLY GENERATED CODE
//   Generated by Mentor Graphics' Register Assistant UVM V4.4 (Build 1)
//   UVM Register Kit version 1.1
//----------------------------------------------------------------------
// Project         : reg
// Unit            : ble_reg_bank_pkg
// File            : ble_reg_bank_pkg.sv
//----------------------------------------------------------------------
// Created by      : acaic
// Creation Date   : 19/8/14 9:38 AM
//----------------------------------------------------------------------
// Title           : reg
//
// Description     : 
//
//----------------------------------------------------------------------

//----------------------------------------------------------------------
// ble_reg_bank_pkg
//----------------------------------------------------------------------
package ble_reg_bank_pkg;


   // Required packages for OVM backward compatibility
   import ovm_pkg::*;
   import uvm_reg_pkg::*;



   // Required includes for OVM backward compatibility
   `include "ovm_macros.svh"
   `include "uvm_reg_macros.svh"


   /* DEFINE REGISTER CLASSES */



   //--------------------------------------------------------------------
   // Class: EDIV
   // 
   //--------------------------------------------------------------------

   class EDIV extends uvm_reg;
      `uvm_object_utils(EDIV)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; // ediv value 2 octet


      // Function: new
      // 
      function new(string name = "EDIV");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: IVs
   // 
   //--------------------------------------------------------------------

   class IVs extends uvm_reg;
      `uvm_object_utils(IVs)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "IVs");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: adv_source_device_addr_msb
   // 
   //--------------------------------------------------------------------

   class adv_source_device_addr_msb extends uvm_reg;
      `uvm_object_utils(adv_source_device_addr_msb)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "adv_source_device_addr_msb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: data_channel_map_reg_lsb
   // 
   //--------------------------------------------------------------------

   class data_channel_map_reg_lsb extends uvm_reg;
      `uvm_object_utils(data_channel_map_reg_lsb)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "data_channel_map_reg_lsb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: adv_source_device_addr_lsb
   // 
   //--------------------------------------------------------------------

   class adv_source_device_addr_lsb extends uvm_reg;
      `uvm_object_utils(adv_source_device_addr_lsb)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "adv_source_device_addr_lsb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: ISR
   // 
   // Interrupt Register
   //--------------------------------------------------------------------

   class ISR extends uvm_reg;
      `uvm_object_utils(ISR)

      rand uvm_reg_field MIC_failure; // Authentication Failure
      rand uvm_reg_field pkt_received; // Failure of CRC calculation
      rand uvm_reg_field pkt_drop; // Interrupt
      rand uvm_reg_field authenticate_timeout; // LE authenticated payload timeout
      rand uvm_reg_field proc_rsp_timeout; // Procedure response timeout
      rand uvm_reg_field kill_conn_aftr_ack; 
      rand uvm_reg_field bad_pkt; 
      rand uvm_reg_field duplicate_pkt; 
      rand uvm_reg_field empty_pkt; 
      rand uvm_reg_field encryption_pause; 
      rand uvm_reg_field encryption_start; 
      rand uvm_reg_field conn_estb_failure; 
      rand uvm_reg_field kill_conn_by_host; 
      rand uvm_reg_field deep_sleep; 
      rand uvm_reg_field ctrl_pdu_stop; // Stop of control PDU
      rand uvm_reg_field ctrl_pdu_start; // Start of control PDU
      rand uvm_reg_field supervision_timeout_reset; // Rest of supervision timeout timer
      rand uvm_reg_field data_pdu_stop; // Stop of data PDU
      rand uvm_reg_field data_pdu_start; // Start of data PDU
      rand uvm_reg_field sleep; // Complete of slave latency
      rand uvm_reg_field conn_supervision_timeout; // Timeout for connection supervision
      rand uvm_reg_field conn_event_estb; // Connection event established
      rand uvm_reg_field conn_event_close; // Close of connection event
      rand uvm_reg_field conn_event_create; // Connection event created
      rand uvm_reg_field conn_req_pkt_stop; // Stop of conn_req PDU
      rand uvm_reg_field conn_req_pkt_start; // Start of conn_req PDU
      rand uvm_reg_field scan_req_stop; // Stop of scan_req PDU
      rand uvm_reg_field scan_req_start; // Start of scan_req PDU
      rand uvm_reg_field scan_rsp_stop; // Stop of scan_rsp PDU
      rand uvm_reg_field scan_rsp_start; // Start of scan_rsp PDU
      rand uvm_reg_field adv_pkt_stop; // Stop of advertising PDU
      rand uvm_reg_field adv_pkt_start; // Start of advertising PDU


      // Function: new
      // 
      function new(string name = "ISR");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         MIC_failure = uvm_reg_field::type_id::create("MIC_failure");
         pkt_received = uvm_reg_field::type_id::create("pkt_received");
         pkt_drop = uvm_reg_field::type_id::create("pkt_drop");
         authenticate_timeout = uvm_reg_field::type_id::create("authenticate_timeout");
         proc_rsp_timeout = uvm_reg_field::type_id::create("proc_rsp_timeout");
         kill_conn_aftr_ack = uvm_reg_field::type_id::create("kill_conn_aftr_ack");
         bad_pkt = uvm_reg_field::type_id::create("bad_pkt");
         duplicate_pkt = uvm_reg_field::type_id::create("duplicate_pkt");
         empty_pkt = uvm_reg_field::type_id::create("empty_pkt");
         encryption_pause = uvm_reg_field::type_id::create("encryption_pause");
         encryption_start = uvm_reg_field::type_id::create("encryption_start");
         conn_estb_failure = uvm_reg_field::type_id::create("conn_estb_failure");
         kill_conn_by_host = uvm_reg_field::type_id::create("kill_conn_by_host");
         deep_sleep = uvm_reg_field::type_id::create("deep_sleep");
         ctrl_pdu_stop = uvm_reg_field::type_id::create("ctrl_pdu_stop");
         ctrl_pdu_start = uvm_reg_field::type_id::create("ctrl_pdu_start");
         supervision_timeout_reset = uvm_reg_field::type_id::create("supervision_timeout_reset");
         data_pdu_stop = uvm_reg_field::type_id::create("data_pdu_stop");
         data_pdu_start = uvm_reg_field::type_id::create("data_pdu_start");
         sleep = uvm_reg_field::type_id::create("sleep");
         conn_supervision_timeout = uvm_reg_field::type_id::create("conn_supervision_timeout");
         conn_event_estb = uvm_reg_field::type_id::create("conn_event_estb");
         conn_event_close = uvm_reg_field::type_id::create("conn_event_close");
         conn_event_create = uvm_reg_field::type_id::create("conn_event_create");
         conn_req_pkt_stop = uvm_reg_field::type_id::create("conn_req_pkt_stop");
         conn_req_pkt_start = uvm_reg_field::type_id::create("conn_req_pkt_start");
         scan_req_stop = uvm_reg_field::type_id::create("scan_req_stop");
         scan_req_start = uvm_reg_field::type_id::create("scan_req_start");
         scan_rsp_stop = uvm_reg_field::type_id::create("scan_rsp_stop");
         scan_rsp_start = uvm_reg_field::type_id::create("scan_rsp_start");
         adv_pkt_stop = uvm_reg_field::type_id::create("adv_pkt_stop");
         adv_pkt_start = uvm_reg_field::type_id::create("adv_pkt_start");

         MIC_failure.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         pkt_received.configure(this, 1, 30, "RW", 0, 1'b0, 1, 1, 0);
         pkt_drop.configure(this, 1, 29, "RW", 0, 1'b0, 1, 1, 0);
         authenticate_timeout.configure(this, 1, 28, "RW", 0, 1'b0, 1, 1, 0);
         proc_rsp_timeout.configure(this, 1, 27, "RW", 0, 1'b0, 1, 1, 0);
         kill_conn_aftr_ack.configure(this, 1, 26, "RW", 0, 1'b0, 1, 1, 0);
         bad_pkt.configure(this, 1, 25, "RW", 0, 1'b0, 1, 1, 0);
         duplicate_pkt.configure(this, 1, 24, "RW", 0, 1'b0, 1, 1, 0);
         empty_pkt.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         encryption_pause.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         encryption_start.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         conn_estb_failure.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         kill_conn_by_host.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         deep_sleep.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         ctrl_pdu_stop.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         ctrl_pdu_start.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         supervision_timeout_reset.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         data_pdu_stop.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         data_pdu_start.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         sleep.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         conn_supervision_timeout.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         conn_event_estb.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         conn_event_close.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         conn_event_create.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         conn_req_pkt_stop.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         conn_req_pkt_start.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         scan_req_stop.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         scan_req_start.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         scan_rsp_stop.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         scan_rsp_start.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         adv_pkt_stop.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         adv_pkt_start.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: init_target_device_addr_msb
   // 
   //--------------------------------------------------------------------

   class init_target_device_addr_msb extends uvm_reg;
      `uvm_object_utils(init_target_device_addr_msb)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "init_target_device_addr_msb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: control_pdu
   // 
   //--------------------------------------------------------------------

   class control_pdu extends uvm_reg;
      `uvm_object_utils(control_pdu)

      uvm_reg_field reserved; 
      rand uvm_reg_field types; // 0x00 : LL_CONNECTION_UPDATE_REQ
                              // 0x01 : LL_CHANNEL_MAP_REQ
                              // 0x02 : LL_TERMINATE_IND
                              // 0x03 : LL_ENC_REQ
                              // 0x04 : LL_ENC_RSP
                              // 0x05 : LL_START_ENC_REQ
                              // 0x06 : LL_START_ENC_RSP
                              // 0x07 : LL_UNKNOWN_RSP
                              // 0x08 : LL_FEATURE_REQ
                              // 0x09 : LL_FEATURE_RSP
                              // 0x0A : LL_PAUSE_ENC_REQ
                              // 0x0B : LL_PAUSE_ENC_RSP
                              // 0x0C : LL_VERSION_IND
                              // 0x0D : LL_REJECT_IND
                              // 0x0E : LL_SLAVE_FEATURE_REQ
                              // 0x0F : LL_CONNECTION_PARAM_REQ
                              // 0x10 : LL_CONNECTION_PARAM_RSP
                              // 0x11 : LL_REJECT_IND_EXT
                              // 0x12 : LL_PING_REQ
                              // 0x13 : LL_PING_RSP
                              // 0x14-0xFF : Reserved for Future Use


      // Function: new
      // 
      function new(string name = "control_pdu");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         types = uvm_reg_field::type_id::create("types");

         reserved.configure(this, 24, 8, "RO", 0, 24'h000000, 1, 0, 1);
         types.configure(this, 8, 0, "RW", 0, 8'h00, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: init_source_device_addr_msb
   // 
   //--------------------------------------------------------------------

   class init_source_device_addr_msb extends uvm_reg;
      `uvm_object_utils(init_source_device_addr_msb)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "init_source_device_addr_msb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: hop_reg
   // 
   //--------------------------------------------------------------------

   class hop_reg extends uvm_reg;
      `uvm_object_utils(hop_reg)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "hop_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 27, 5, "RO", 0, 27'b000000000000000000000000000, 1, 0, 0);
         data.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: data_channel_map_reg_msb
   // 
   //--------------------------------------------------------------------

   class data_channel_map_reg_msb extends uvm_reg;
      `uvm_object_utils(data_channel_map_reg_msb)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "data_channel_map_reg_msb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 27, 5, "RO", 0, 27'b000000000000000000000000000, 1, 0, 0);
         data.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: conn_interval_max_reg
   // 
   //--------------------------------------------------------------------

   class conn_interval_max_reg extends uvm_reg;
      `uvm_object_utils(conn_interval_max_reg)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "conn_interval_max_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: Ivm
   // 
   //--------------------------------------------------------------------

   class Ivm extends uvm_reg;
      `uvm_object_utils(Ivm)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "Ivm");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: IE
   // 
   // Interrupt Enable
   //--------------------------------------------------------------------

   class IE extends uvm_reg;
      `uvm_object_utils(IE)

      rand uvm_reg_field MIC_failure; 
      uvm_reg_field pkt_received; 
      rand uvm_reg_field pkt_drop; 
      rand uvm_reg_field authenticate_timeout; 
      rand uvm_reg_field proc_rsp_timeout; 
      rand uvm_reg_field kill_conn_aftr_ack; 
      rand uvm_reg_field bad_pkt; 
      rand uvm_reg_field duplicate_pkt; 
      rand uvm_reg_field empty_pkt; 
      rand uvm_reg_field encryption_pause; 
      rand uvm_reg_field encryption_start; 
      rand uvm_reg_field conn_estb_failure; 
      rand uvm_reg_field kill_conn_by_host; 
      rand uvm_reg_field deep_sleep; 
      rand uvm_reg_field ctrl_pdu_stop; 
      rand uvm_reg_field ctrl_pdu_start; 
      rand uvm_reg_field supervision_timeout_reset; 
      rand uvm_reg_field data_pdu_stop; 
      rand uvm_reg_field data_pdu_start; 
      rand uvm_reg_field sleep; 
      rand uvm_reg_field conn_supervision_timeout; 
      rand uvm_reg_field conn_event_estb; 
      rand uvm_reg_field conn_event_close; 
      rand uvm_reg_field conn_event_create; 
      rand uvm_reg_field conn_req_pkt_stop; 
      rand uvm_reg_field conn_req_pkt_start; 
      rand uvm_reg_field scan_req_start; 
      rand uvm_reg_field scan_req_stop; 
      rand uvm_reg_field scan_rsp_stop; 
      rand uvm_reg_field scan_rsp_start; 
      rand uvm_reg_field adv_pkt_stop; 
      rand uvm_reg_field adv_pkt_start; 


      // Function: new
      // 
      function new(string name = "IE");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         MIC_failure = uvm_reg_field::type_id::create("MIC_failure");
         pkt_received = uvm_reg_field::type_id::create("pkt_received");
         pkt_drop = uvm_reg_field::type_id::create("pkt_drop");
         authenticate_timeout = uvm_reg_field::type_id::create("authenticate_timeout");
         proc_rsp_timeout = uvm_reg_field::type_id::create("proc_rsp_timeout");
         kill_conn_aftr_ack = uvm_reg_field::type_id::create("kill_conn_aftr_ack");
         bad_pkt = uvm_reg_field::type_id::create("bad_pkt");
         duplicate_pkt = uvm_reg_field::type_id::create("duplicate_pkt");
         empty_pkt = uvm_reg_field::type_id::create("empty_pkt");
         encryption_pause = uvm_reg_field::type_id::create("encryption_pause");
         encryption_start = uvm_reg_field::type_id::create("encryption_start");
         conn_estb_failure = uvm_reg_field::type_id::create("conn_estb_failure");
         kill_conn_by_host = uvm_reg_field::type_id::create("kill_conn_by_host");
         deep_sleep = uvm_reg_field::type_id::create("deep_sleep");
         ctrl_pdu_stop = uvm_reg_field::type_id::create("ctrl_pdu_stop");
         ctrl_pdu_start = uvm_reg_field::type_id::create("ctrl_pdu_start");
         supervision_timeout_reset = uvm_reg_field::type_id::create("supervision_timeout_reset");
         data_pdu_stop = uvm_reg_field::type_id::create("data_pdu_stop");
         data_pdu_start = uvm_reg_field::type_id::create("data_pdu_start");
         sleep = uvm_reg_field::type_id::create("sleep");
         conn_supervision_timeout = uvm_reg_field::type_id::create("conn_supervision_timeout");
         conn_event_estb = uvm_reg_field::type_id::create("conn_event_estb");
         conn_event_close = uvm_reg_field::type_id::create("conn_event_close");
         conn_event_create = uvm_reg_field::type_id::create("conn_event_create");
         conn_req_pkt_stop = uvm_reg_field::type_id::create("conn_req_pkt_stop");
         conn_req_pkt_start = uvm_reg_field::type_id::create("conn_req_pkt_start");
         scan_req_start = uvm_reg_field::type_id::create("scan_req_start");
         scan_req_stop = uvm_reg_field::type_id::create("scan_req_stop");
         scan_rsp_stop = uvm_reg_field::type_id::create("scan_rsp_stop");
         scan_rsp_start = uvm_reg_field::type_id::create("scan_rsp_start");
         adv_pkt_stop = uvm_reg_field::type_id::create("adv_pkt_stop");
         adv_pkt_start = uvm_reg_field::type_id::create("adv_pkt_start");

         MIC_failure.configure(this, 1, 31, "RW", 0, 1'b0, 1, 1, 0);
         pkt_received.configure(this, 1, 30, "RW", 0, 1'b0, 1, 0, 0);
         pkt_drop.configure(this, 1, 29, "RW", 0, 1'b0, 1, 1, 0);
         authenticate_timeout.configure(this, 1, 28, "RW", 0, 1'b0, 1, 1, 0);
         proc_rsp_timeout.configure(this, 1, 27, "RW", 0, 1'b0, 1, 1, 0);
         kill_conn_aftr_ack.configure(this, 1, 26, "RW", 0, 1'b0, 1, 1, 0);
         bad_pkt.configure(this, 1, 25, "RW", 0, 1'b0, 1, 1, 0);
         duplicate_pkt.configure(this, 1, 24, "RW", 0, 1'b0, 1, 1, 0);
         empty_pkt.configure(this, 1, 23, "RW", 0, 1'b0, 1, 1, 0);
         encryption_pause.configure(this, 1, 22, "RW", 0, 1'b0, 1, 1, 0);
         encryption_start.configure(this, 1, 21, "RW", 0, 1'b0, 1, 1, 0);
         conn_estb_failure.configure(this, 1, 20, "RW", 0, 1'b0, 1, 1, 0);
         kill_conn_by_host.configure(this, 1, 19, "RW", 0, 1'b0, 1, 1, 0);
         deep_sleep.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         ctrl_pdu_stop.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         ctrl_pdu_start.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         supervision_timeout_reset.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         data_pdu_stop.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         data_pdu_start.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         sleep.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         conn_supervision_timeout.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         conn_event_estb.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         conn_event_close.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         conn_event_create.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         conn_req_pkt_stop.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         conn_req_pkt_start.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         scan_req_stop.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         scan_req_start.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         scan_rsp_stop.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         scan_rsp_start.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         adv_pkt_stop.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         adv_pkt_start.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: encrypt_rand_lsb
   // 
   //--------------------------------------------------------------------

   class encrypt_rand_lsb extends uvm_reg;
      `uvm_object_utils(encrypt_rand_lsb)

      rand uvm_reg_field data; // random number for LE encryption


      // Function: new
      // 
      function new(string name = "encrypt_rand_lsb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: encrypt_rand_msb
   // 
   //--------------------------------------------------------------------

   class encrypt_rand_msb extends uvm_reg;
      `uvm_object_utils(encrypt_rand_msb)

      rand uvm_reg_field data; // random number for LE encryption


      // Function: new
      // 
      function new(string name = "encrypt_rand_msb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: init_source_device_addr_lsb
   // 
   //--------------------------------------------------------------------

   class init_source_device_addr_lsb extends uvm_reg;
      `uvm_object_utils(init_source_device_addr_lsb)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "init_source_device_addr_lsb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: window_size_reg
   // 
   //--------------------------------------------------------------------

   class window_size_reg extends uvm_reg;
      `uvm_object_utils(window_size_reg)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "window_size_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 24, 8, "RO", 0, 24'h000000, 1, 0, 1);
         data.configure(this, 8, 0, "RW", 0, 8'h00, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: conn_interval_min_reg
   // 
   //--------------------------------------------------------------------

   class conn_interval_min_reg extends uvm_reg;
      `uvm_object_utils(conn_interval_min_reg)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "conn_interval_min_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: SKDm_lsb
   // 
   //--------------------------------------------------------------------

   class SKDm_lsb extends uvm_reg;
      `uvm_object_utils(SKDm_lsb)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "SKDm_lsb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: init_target_device_addr_lsb
   // 
   //--------------------------------------------------------------------

   class init_target_device_addr_lsb extends uvm_reg;
      `uvm_object_utils(init_target_device_addr_lsb)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "init_target_device_addr_lsb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: CRC_init_value
   // 
   //--------------------------------------------------------------------

   class CRC_init_value extends uvm_reg;
      `uvm_object_utils(CRC_init_value)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "CRC_init_value");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 8, 24, "RO", 0, 8'h00, 1, 0, 1);
         data.configure(this, 24, 0, "RW", 0, 24'h000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: channel_access_addr
   // 
   //--------------------------------------------------------------------

   class channel_access_addr extends uvm_reg;
      `uvm_object_utils(channel_access_addr)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "channel_access_addr");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: adv_interval_max_reg
   // 
   //--------------------------------------------------------------------

   class adv_interval_max_reg extends uvm_reg;
      `uvm_object_utils(adv_interval_max_reg)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "adv_interval_max_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: scan_target_device_addr_msb
   // 
   //--------------------------------------------------------------------

   class scan_target_device_addr_msb extends uvm_reg;
      `uvm_object_utils(scan_target_device_addr_msb)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "scan_target_device_addr_msb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: LTK_3
   // 
   //--------------------------------------------------------------------

   class LTK_3 extends uvm_reg;
      `uvm_object_utils(LTK_3)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "LTK_3");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: SKDm_msb
   // 
   //--------------------------------------------------------------------

   class SKDm_msb extends uvm_reg;
      `uvm_object_utils(SKDm_msb)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "SKDm_msb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: LTK_2
   // 
   //--------------------------------------------------------------------

   class LTK_2 extends uvm_reg;
      `uvm_object_utils(LTK_2)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "LTK_2");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: LTK_1
   // 
   //--------------------------------------------------------------------

   class LTK_1 extends uvm_reg;
      `uvm_object_utils(LTK_1)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "LTK_1");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: scan_params
   // 
   //--------------------------------------------------------------------

   class scan_params extends uvm_reg;
      `uvm_object_utils(scan_params)

      uvm_reg_field reserved; 
      rand uvm_reg_field length; // length for scan response
      rand uvm_reg_field filter_policy; // oN/OFF
      rand uvm_reg_field own_addr_type; // public or random
      rand uvm_reg_field scan_type; // 0 ╬ô├ç├┤ active
                                    // 1 ╬ô├ç├┤ Passive


      // Function: new
      // 
      function new(string name = "scan_params");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         length = uvm_reg_field::type_id::create("length");
         filter_policy = uvm_reg_field::type_id::create("filter_policy");
         own_addr_type = uvm_reg_field::type_id::create("own_addr_type");
         scan_type = uvm_reg_field::type_id::create("scan_type");

         reserved.configure(this, 22, 10, "RO", 0, 22'b0000000000000000000000, 1, 0, 0);
         length.configure(this, 6, 4, "RW", 0, 6'b000000, 1, 1, 0);
         filter_policy.configure(this, 2, 2, "RW", 0, 2'b00, 1, 1, 0);
         own_addr_type.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         scan_type.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: LTK_0
   // 
   //--------------------------------------------------------------------

   class LTK_0 extends uvm_reg;
      `uvm_object_utils(LTK_0)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "LTK_0");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: scan_target_device_addr_lsb
   // 
   //--------------------------------------------------------------------

   class scan_target_device_addr_lsb extends uvm_reg;
      `uvm_object_utils(scan_target_device_addr_lsb)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "scan_target_device_addr_lsb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: window_offset_reg
   // 
   //--------------------------------------------------------------------

   class window_offset_reg extends uvm_reg;
      `uvm_object_utils(window_offset_reg)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "window_offset_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: company_id
   // 
   //--------------------------------------------------------------------

   class company_id extends uvm_reg;
      `uvm_object_utils(company_id)

      uvm_reg_field reserved; 
      rand uvm_reg_field id; 


      // Function: new
      // 
      function new(string name = "company_id");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         id = uvm_reg_field::type_id::create("id");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         id.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: SKDs_msb
   // 
   //--------------------------------------------------------------------

   class SKDs_msb extends uvm_reg;
      `uvm_object_utils(SKDs_msb)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "SKDs_msb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: scan_interval_reg
   // 
   //--------------------------------------------------------------------

   class scan_interval_reg extends uvm_reg;
      `uvm_object_utils(scan_interval_reg)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "scan_interval_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: scan_window_reg
   // 
   //--------------------------------------------------------------------

   class scan_window_reg extends uvm_reg;
      `uvm_object_utils(scan_window_reg)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "scan_window_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: sup_timeout_reg
   // 
   //--------------------------------------------------------------------

   class sup_timeout_reg extends uvm_reg;
      `uvm_object_utils(sup_timeout_reg)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "sup_timeout_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: adv_interval_min_reg
   // 
   //--------------------------------------------------------------------

   class adv_interval_min_reg extends uvm_reg;
      `uvm_object_utils(adv_interval_min_reg)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "adv_interval_min_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: adv_rx_type
   // 
   //--------------------------------------------------------------------

   class adv_rx_type extends uvm_reg;
      `uvm_object_utils(adv_rx_type)

      uvm_reg_field reserved; 
      rand uvm_reg_field types; // 0011-SCAN_REQ_PDU
                              // 0101-CONN_REQ_PDU


      // Function: new
      // 
      function new(string name = "adv_rx_type");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         types = uvm_reg_field::type_id::create("types");

         reserved.configure(this, 28, 4, "RO", 0, 28'h0000000, 1, 0, 0);
         types.configure(this, 4, 0, "RW", 0, 4'h0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: adv_params
   // 
   // Advertising PDU types
   //--------------------------------------------------------------------

   class adv_params extends uvm_reg;
      `uvm_object_utils(adv_params)

      uvm_reg_field reserved; 
      rand uvm_reg_field length; 
      rand uvm_reg_field filter_policy; // 0x00 Process scan and connection requests from all devices (i.e., the White List is not in use) ( default ).devices that are in the White List.devices that are in the White List..
                                       // 0x02 Process scan requests from all devices and only connection requests from
                                       // 0x01 Process connection requests from all devices and only scan requests from
                                       // 0x03 Process scan and connection requests only from devices in the White List.
      rand uvm_reg_field adv_channel_map; // 001 ╬ô├ç├┤ channel 37
                                          // 010 ╬ô├ç├┤ channel 38
                                          // 100 ╬ô├ç├┤ channel 39
                                          // 011 ╬ô├ç├┤ channel 37,38
                                          // 111 ╬ô├ç├┤ channel 37,38,39 ╬ô├ç┬¬ etc
      rand uvm_reg_field direct_addr_type; // 0-public 
                                          // 1- random
      rand uvm_reg_field own_addr_type; // 0-public 
                                       // 1- random
      rand uvm_reg_field duty_cycle_type; // 0-low_duty_cycle
                                          // 1-high_duty_cycle
      rand uvm_reg_field adv_type; // 0000-ADV_IND
                                 // 0001-ADV_DIRECTED_IND_hduty
                                 // 0010-ADV_SCAN_IND
                                 // 0110-SCAN_undirected
                                 // 0111-CONN_directed_lduty
                                 // 0100-SCAN_RSP_PDU


      // Function: new
      // 
      function new(string name = "adv_params");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         length = uvm_reg_field::type_id::create("length");
         filter_policy = uvm_reg_field::type_id::create("filter_policy");
         adv_channel_map = uvm_reg_field::type_id::create("adv_channel_map");
         direct_addr_type = uvm_reg_field::type_id::create("direct_addr_type");
         own_addr_type = uvm_reg_field::type_id::create("own_addr_type");
         duty_cycle_type = uvm_reg_field::type_id::create("duty_cycle_type");
         adv_type = uvm_reg_field::type_id::create("adv_type");

         reserved.configure(this, 14, 18, "RO", 0, 14'b00000, 1, 0, 0);
         length.configure(this, 6, 12, "RW", 0, 6'b000000, 1, 1, 0);
         filter_policy.configure(this, 2, 10, "RW", 0, 2'b00, 1, 1, 0);
         adv_channel_map.configure(this, 3, 7, "RW", 0, 3'b000, 1, 1, 0);
         direct_addr_type.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         own_addr_type.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         duty_cycle_type.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         adv_type.configure(this, 4, 0, "RW", 0, 4'h0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: scan_source_device_addr_msb
   // 
   //--------------------------------------------------------------------

   class scan_source_device_addr_msb extends uvm_reg;
      `uvm_object_utils(scan_source_device_addr_msb)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "scan_source_device_addr_msb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: version
   // 
   //--------------------------------------------------------------------

   class version extends uvm_reg;
      `uvm_object_utils(version)

      uvm_reg_field reserved; 
      rand uvm_reg_field sub_vrsn_num; 
      rand uvm_reg_field vrsn_num; 


      // Function: new
      // 
      function new(string name = "version");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         sub_vrsn_num = uvm_reg_field::type_id::create("sub_vrsn_num");
         vrsn_num = uvm_reg_field::type_id::create("vrsn_num");

         reserved.configure(this, 8, 24, "RO", 0, 8'h00, 1, 0, 1);
         sub_vrsn_num.configure(this, 16, 8, "RW", 0, 16'h0000, 1, 1, 1);
         vrsn_num.configure(this, 8, 0, "RW", 0, 8'h00, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: state_register
   // 
   // state_register
   //--------------------------------------------------------------------

   class state_register extends uvm_reg;
      `uvm_object_utils(state_register)

      uvm_reg_field reserved; 
      rand uvm_reg_field CONNECT; 
      rand uvm_reg_field INIT; 
      rand uvm_reg_field SCAN; 
      rand uvm_reg_field ADV; 
      rand uvm_reg_field IDLE; 


      // Function: new
      // 
      function new(string name = "state_register");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         CONNECT = uvm_reg_field::type_id::create("CONNECT");
         INIT = uvm_reg_field::type_id::create("INIT");
         SCAN = uvm_reg_field::type_id::create("SCAN");
         ADV = uvm_reg_field::type_id::create("ADV");
         IDLE = uvm_reg_field::type_id::create("IDLE");

         reserved.configure(this, 27, 5, "RO", 0, 27'b000000000000000000000000000, 1, 0, 0);
         CONNECT.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         INIT.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         SCAN.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         ADV.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         IDLE.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: authenticated_payload_timeout
   // 
   //--------------------------------------------------------------------

   class authenticated_payload_timeout extends uvm_reg;
      `uvm_object_utils(authenticated_payload_timeout)

      uvm_reg_field reserved; 
      rand uvm_reg_field timeout; 


      // Function: new
      // 
      function new(string name = "authenticated_payload_timeout");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         timeout = uvm_reg_field::type_id::create("timeout");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         timeout.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: conn_interval_reg
   // 
   //--------------------------------------------------------------------

   class conn_interval_reg extends uvm_reg;
      `uvm_object_utils(conn_interval_reg)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "conn_interval_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: SKDs_lsb
   // 
   //--------------------------------------------------------------------

   class SKDs_lsb extends uvm_reg;
      `uvm_object_utils(SKDs_lsb)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "SKDs_lsb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: data_pdu
   // 
   //--------------------------------------------------------------------

   class data_pdu extends uvm_reg;
      `uvm_object_utils(data_pdu)

      uvm_reg_field reserved; 
      rand uvm_reg_field LLID; 
      rand uvm_reg_field NESN; 
      rand uvm_reg_field SN; 
      rand uvm_reg_field MD; 
      rand uvm_reg_field length; 

      // Constraints 
      


      // Function: new
      // 
      function new(string name = "data_pdu");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         LLID = uvm_reg_field::type_id::create("LLID");
         NESN = uvm_reg_field::type_id::create("NESN");
         SN = uvm_reg_field::type_id::create("SN");
         MD = uvm_reg_field::type_id::create("MD");
         length = uvm_reg_field::type_id::create("length");

         reserved.configure(this, 22, 10, "RO", 0, 22'b0000000000000000000000, 1, 0, 0);
         LLID.configure(this, 2, 8, "RW", 0, 2'b00, 1, 1, 0);
         NESN.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         SN.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         MD.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         length.configure(this, 5, 0, "RW", 0, 5'b00000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: feature_exchange
   // 
   //--------------------------------------------------------------------

   class feature_exchange extends uvm_reg;
      `uvm_object_utils(feature_exchange)

      uvm_reg_field reserved; 
      rand uvm_reg_field host_controller; // 0-controller to host(supports)
                                          // 1-controller to controller(enabled)
      rand uvm_reg_field LE_ping; 
      rand uvm_reg_field slv_init_feature_exchange; 
      rand uvm_reg_field ext_rej_ind; 
      rand uvm_reg_field conn_param_req_proc; 
      rand uvm_reg_field LE_enryption; 


      // Function: new
      // 
      function new(string name = "feature_exchange");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         host_controller = uvm_reg_field::type_id::create("host_controller");
         LE_ping = uvm_reg_field::type_id::create("LE_ping");
         slv_init_feature_exchange = uvm_reg_field::type_id::create("slv_init_feature_exchange");
         ext_rej_ind = uvm_reg_field::type_id::create("ext_rej_ind");
         conn_param_req_proc = uvm_reg_field::type_id::create("conn_param_req_proc");
         LE_enryption = uvm_reg_field::type_id::create("LE_enryption");

         reserved.configure(this, 26, 6, "RO", 0, 26'b00000000000000000000000000, 1, 0, 0);
         host_controller.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         LE_ping.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         slv_init_feature_exchange.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         ext_rej_ind.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         conn_param_req_proc.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         LE_enryption.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: adv_direct_addr_msb
   // 
   //--------------------------------------------------------------------

   class adv_direct_addr_msb extends uvm_reg;
      `uvm_object_utils(adv_direct_addr_msb)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "adv_direct_addr_msb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'b0, 1, 0, 0);
         data.configure(this, 16, 0, "RW", 0, 16'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: init_reg
   // 
   //--------------------------------------------------------------------

   class init_reg extends uvm_reg;
      `uvm_object_utils(init_reg)

      uvm_reg_field reserved; 
      rand uvm_reg_field own_addr_type; // 0 ╬ô├ç├┤ public
                                       // 1 - random
      rand uvm_reg_field peer_addr_type; // 0 ╬ô├ç├┤ public
                                       // 1 - random
      rand uvm_reg_field filter_policy; // 0x00 White list is not used to determine which advertiser to connect to.
                                       // Peer_Address_Type and Peer_Address shall be used.
                                       // 0x01 White list is used to determine which advertiser to connect to.
                                       // Others- NA


      // Function: new
      // 
      function new(string name = "init_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         own_addr_type = uvm_reg_field::type_id::create("own_addr_type");
         peer_addr_type = uvm_reg_field::type_id::create("peer_addr_type");
         filter_policy = uvm_reg_field::type_id::create("filter_policy");

         reserved.configure(this, 28, 4, "RO", 0, 28'h0000000, 1, 0, 0);
         own_addr_type.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         peer_addr_type.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         filter_policy.configure(this, 2, 0, "RW", 0, 2'b00, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: adv_direct_addr_lsb
   // 
   //--------------------------------------------------------------------

   class adv_direct_addr_lsb extends uvm_reg;
      `uvm_object_utils(adv_direct_addr_lsb)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "adv_direct_addr_lsb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: SCA
   // 
   //--------------------------------------------------------------------

   class SCA extends uvm_reg;
      `uvm_object_utils(SCA)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "SCA");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 29, 3, "RO", 0, 29'b00000000000000000000000000000, 1, 0, 0);
         data.configure(this, 3, 0, "RW", 0, 3'b000, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: command_reg
   // 
   //--------------------------------------------------------------------

   class command_reg extends uvm_reg;
      `uvm_object_utils(command_reg)

      uvm_reg_field reserved; 
      rand uvm_reg_field start_read; // Software reset. Resets all the hardware registers
      rand uvm_reg_field soft_reset; // Software reset. Resets all the hardware registers
      rand uvm_reg_field reset_read_ptr; // Reset the white list memory read pointer to 0.
      rand uvm_reg_field resp_timer_off; // Stop PDU response timer.
      rand uvm_reg_field resp_timer_on; // Start PDU response timer. The timer register must be pro-grammed with timeout value before issuing this command.
      rand uvm_reg_field kill_conn_after_tx; // Kill connection after a transmit operation is over.
      rand uvm_reg_field kill_conn; // Kill connection immediately.
      rand uvm_reg_field packet_received; // Indicates a received connection packet is read by firmware from connection receive FIFO.
      rand uvm_reg_field update_conn_proc; // Start connection update procedure for the connection
      rand uvm_reg_field update_chan_map; // Update channel map for the connection.
      rand uvm_reg_field update_conn_par; // Update connection parameters.
      rand uvm_reg_field enter_dsm; // Enter deep sleep mode.
      rand uvm_reg_field enter_sm; // Enter sleep mode
      rand uvm_reg_field init_stop; // Cancel connection creation operation.
      rand uvm_reg_field init_start; // Start connection creation operation. The associated configuration registers must be programmed before the command is issued.
      rand uvm_reg_field scan_stop; // Stop the scanner operation.
      rand uvm_reg_field scan_start; // Start scanner operation. The associated SCANNER configuration registers must be programmed before the command is issued. 
      rand uvm_reg_field adv_stop; // Stop advertiser operation.
      rand uvm_reg_field adv_start; // Start Advertiser operation. The associated Advertiser configuration registers are programmed before the command is issued.


      // Function: new
      // 
      function new(string name = "command_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         start_read = uvm_reg_field::type_id::create("start_read");
         soft_reset = uvm_reg_field::type_id::create("soft_reset");
         reset_read_ptr = uvm_reg_field::type_id::create("reset_read_ptr");
         resp_timer_off = uvm_reg_field::type_id::create("resp_timer_off");
         resp_timer_on = uvm_reg_field::type_id::create("resp_timer_on");
         kill_conn_after_tx = uvm_reg_field::type_id::create("kill_conn_after_tx");
         kill_conn = uvm_reg_field::type_id::create("kill_conn");
         packet_received = uvm_reg_field::type_id::create("packet_received");
         update_conn_proc = uvm_reg_field::type_id::create("update_conn_proc");
         update_chan_map = uvm_reg_field::type_id::create("update_chan_map");
         update_conn_par = uvm_reg_field::type_id::create("update_conn_par");
         enter_dsm = uvm_reg_field::type_id::create("enter_dsm");
         enter_sm = uvm_reg_field::type_id::create("enter_sm");
         init_stop = uvm_reg_field::type_id::create("init_stop");
         init_start = uvm_reg_field::type_id::create("init_start");
         scan_stop = uvm_reg_field::type_id::create("scan_stop");
         scan_start = uvm_reg_field::type_id::create("scan_start");
         adv_stop = uvm_reg_field::type_id::create("adv_stop");
         adv_start = uvm_reg_field::type_id::create("adv_start");

         reserved.configure(this, 13, 19, "RO", 0, 13'b0, 1, 0, 0);
         start_read.configure(this, 1, 18, "RW", 0, 1'b0, 1, 1, 0);
         soft_reset.configure(this, 1, 17, "RW", 0, 1'b0, 1, 1, 0);
         reset_read_ptr.configure(this, 1, 16, "RW", 0, 1'b0, 1, 1, 0);
         resp_timer_off.configure(this, 1, 15, "RW", 0, 1'b0, 1, 1, 0);
         resp_timer_on.configure(this, 1, 14, "RW", 0, 1'b0, 1, 1, 0);
         kill_conn_after_tx.configure(this, 1, 13, "RW", 0, 1'b0, 1, 1, 0);
         kill_conn.configure(this, 1, 12, "RW", 0, 1'b0, 1, 1, 0);
         packet_received.configure(this, 1, 11, "RW", 0, 1'b0, 1, 1, 0);
         update_conn_proc.configure(this, 1, 10, "RW", 0, 1'b0, 1, 1, 0);
         update_chan_map.configure(this, 1, 9, "RW", 0, 1'b0, 1, 1, 0);
         update_conn_par.configure(this, 1, 8, "RW", 0, 1'b0, 1, 1, 0);
         enter_dsm.configure(this, 1, 7, "RW", 0, 1'b0, 1, 1, 0);
         enter_sm.configure(this, 1, 6, "RW", 0, 1'b0, 1, 1, 0);
         init_stop.configure(this, 1, 5, "RW", 0, 1'b0, 1, 1, 0);
         init_start.configure(this, 1, 4, "RW", 0, 1'b0, 1, 1, 0);
         scan_stop.configure(this, 1, 3, "RW", 0, 1'b0, 1, 1, 0);
         scan_start.configure(this, 1, 2, "RW", 0, 1'b0, 1, 1, 0);
         adv_stop.configure(this, 1, 1, "RW", 0, 1'b0, 1, 1, 0);
         adv_start.configure(this, 1, 0, "RW", 0, 1'b0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: latency_reg
   // 
   //--------------------------------------------------------------------

   class latency_reg extends uvm_reg;
      `uvm_object_utils(latency_reg)

      uvm_reg_field reserved; 
      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "latency_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         data = uvm_reg_field::type_id::create("data");

         reserved.configure(this, 16, 16, "RO", 0, 16'h0000, 1, 0, 1);
         data.configure(this, 16, 0, "RW", 0, 16'h0000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: scan_source_device_addr_lsb
   // 
   //--------------------------------------------------------------------

   class scan_source_device_addr_lsb extends uvm_reg;
      `uvm_object_utils(scan_source_device_addr_lsb)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "scan_source_device_addr_lsb");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: scan_rx_type
   // 
   //--------------------------------------------------------------------

   class scan_rx_type extends uvm_reg;
      `uvm_object_utils(scan_rx_type)

      uvm_reg_field reserved; 
      rand uvm_reg_field types; 


      // Function: new
      // 
      function new(string name = "scan_rx_type");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         reserved = uvm_reg_field::type_id::create("reserved");
         types = uvm_reg_field::type_id::create("types");

         reserved.configure(this, 28, 4, "RO", 0, 28'h0000000, 1, 0, 0);
         types.configure(this, 4, 0, "RW", 0, 4'h0, 1, 1, 0);
      endfunction
   endclass



   //--------------------------------------------------------------------
   // Class: adv_interval_reg
   // 
   //--------------------------------------------------------------------

   class adv_interval_reg extends uvm_reg;
      `uvm_object_utils(adv_interval_reg)

      rand uvm_reg_field data; 


      // Function: new
      // 
      function new(string name = "adv_interval_reg");
         super.new(name, 32, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         data = uvm_reg_field::type_id::create("data");

         data.configure(this, 32, 0, "RW", 0, 32'h00000000, 1, 1, 1);
      endfunction
   endclass




   /* BLOCKS */



   //--------------------------------------------------------------------
   // Class: ble_reg_block
   // 
   //--------------------------------------------------------------------

   class ble_reg_block extends uvm_reg_block;
      `uvm_object_utils(ble_reg_block)

      rand state_register state_register_h; // state_register
      rand adv_params adv_params_h; // Advertising PDU types
      rand adv_source_device_addr_lsb adv_source_device_addr_lsb_h; 
      rand adv_source_device_addr_msb adv_source_device_addr_msb_h; 
      rand adv_interval_reg adv_interval_reg_h; 
      rand adv_interval_min_reg adv_interval_min_reg_h; 
      rand adv_interval_max_reg adv_interval_max_reg_h; 
      rand adv_direct_addr_lsb adv_direct_addr_lsb_h; 
      rand adv_direct_addr_msb adv_direct_addr_msb_h; 
      rand adv_rx_type adv_rx_type_h; 
      rand scan_params scan_params_h; 
      rand scan_source_device_addr_lsb scan_source_device_addr_lsb_h; 
      rand scan_source_device_addr_msb scan_source_device_addr_msb_h; 
      rand scan_target_device_addr_lsb scan_target_device_addr_lsb_h; 
      rand scan_target_device_addr_msb scan_target_device_addr_msb_h; 
      rand scan_rx_type scan_rx_type_h; 
      rand scan_interval_reg scan_interval_reg_h; 
      rand scan_window_reg scan_window_reg_h; 
      rand init_reg init_reg_h; 
      rand init_source_device_addr_lsb init_source_device_addr_lsb_h; 
      rand init_source_device_addr_msb init_source_device_addr_msb_h; 
      rand init_target_device_addr_lsb init_target_device_addr_lsb_h; 
      rand init_target_device_addr_msb init_target_device_addr_msb_h; 
      rand channel_access_addr channel_access_addr_h; 
      rand CRC_init_value CRC_init_value_h; 
      rand window_size_reg window_size_reg_h; 
      rand window_offset_reg window_offset_reg_h; 
      rand conn_interval_reg conn_interval_reg_h; 
      rand conn_interval_min_reg conn_interval_min_reg_h; 
      rand conn_interval_max_reg conn_interval_max_reg_h; 
      rand latency_reg latency_reg_h; 
      rand sup_timeout_reg sup_timeout_reg_h; 
      rand data_channel_map_reg_lsb data_channel_map_reg_lsb_h; 
      rand data_channel_map_reg_msb data_channel_map_reg_msb_h; 
      rand hop_reg hop_reg_h; 
      rand SCA SCA_h; 
      rand control_pdu control_pdu_h; 
      rand data_pdu data_pdu_h; 
      rand feature_exchange feature_exchange_h; 
      rand encrypt_rand_lsb encrypt_rand_lsb_h; 
      rand encrypt_rand_msb encrypt_rand_msb_h; 
      rand EDIV EDIV_h; 
      rand LTK_0 LTK_0_h; 
      rand LTK_1 LTK_1_h; 
      rand LTK_2 LTK_2_h; 
      rand LTK_3 LTK_3_h; 
      rand SKDm_msb SKDm_msb_h; 
      rand SKDm_lsb SKDm_lsb_h; 
      rand Ivm Ivm_h; 
      rand SKDs_msb SKDs_msb_h; 
      rand SKDs_lsb SKDs_lsb_h; 
      rand IVs Ivs_h; 
      rand authenticated_payload_timeout authenticated_payload_timeout_h; 
      rand version version_h; 
      rand company_id company_id_h; 
      rand ISR ISR_h; // Interrupt Register
      rand IE IE_h; // Interrupt Enable
      rand command_reg command_reg_h; 

      uvm_reg_map bt_map; 


      // Function: new
      // 
      function new(string name = "ble_reg_block");
         super.new(name, UVM_NO_COVERAGE);
      endfunction


      // Function: build
      // 
      virtual function void build();
         state_register_h = state_register::type_id::create("state_register_h");
         state_register_h.configure(this);
         state_register_h.build();

         adv_params_h = adv_params::type_id::create("adv_params_h");
         adv_params_h.configure(this);
         adv_params_h.build();

         adv_source_device_addr_lsb_h = adv_source_device_addr_lsb::type_id::create("adv_source_device_addr_lsb_h");
         adv_source_device_addr_lsb_h.configure(this);
         adv_source_device_addr_lsb_h.build();

         adv_source_device_addr_msb_h = adv_source_device_addr_msb::type_id::create("adv_source_device_addr_msb_h");
         adv_source_device_addr_msb_h.configure(this);
         adv_source_device_addr_msb_h.build();

         adv_interval_reg_h = adv_interval_reg::type_id::create("adv_interval_reg_h");
         adv_interval_reg_h.configure(this);
         adv_interval_reg_h.build();

         adv_interval_min_reg_h = adv_interval_min_reg::type_id::create("adv_interval_min_reg_h");
         adv_interval_min_reg_h.configure(this);
         adv_interval_min_reg_h.build();

         adv_interval_max_reg_h = adv_interval_max_reg::type_id::create("adv_interval_max_reg_h");
         adv_interval_max_reg_h.configure(this);
         adv_interval_max_reg_h.build();

         adv_direct_addr_lsb_h = adv_direct_addr_lsb::type_id::create("adv_direct_addr_lsb_h");
         adv_direct_addr_lsb_h.configure(this);
         adv_direct_addr_lsb_h.build();

         adv_direct_addr_msb_h = adv_direct_addr_msb::type_id::create("adv_direct_addr_msb_h");
         adv_direct_addr_msb_h.configure(this);
         adv_direct_addr_msb_h.build();

         adv_rx_type_h = adv_rx_type::type_id::create("adv_rx_type_h");
         adv_rx_type_h.configure(this);
         adv_rx_type_h.build();

         scan_params_h = scan_params::type_id::create("scan_params_h");
         scan_params_h.configure(this);
         scan_params_h.build();

         scan_source_device_addr_lsb_h = scan_source_device_addr_lsb::type_id::create("scan_source_device_addr_lsb_h");
         scan_source_device_addr_lsb_h.configure(this);
         scan_source_device_addr_lsb_h.build();

         scan_source_device_addr_msb_h = scan_source_device_addr_msb::type_id::create("scan_source_device_addr_msb_h");
         scan_source_device_addr_msb_h.configure(this);
         scan_source_device_addr_msb_h.build();

         scan_target_device_addr_lsb_h = scan_target_device_addr_lsb::type_id::create("scan_target_device_addr_lsb_h");
         scan_target_device_addr_lsb_h.configure(this);
         scan_target_device_addr_lsb_h.build();

         scan_target_device_addr_msb_h = scan_target_device_addr_msb::type_id::create("scan_target_device_addr_msb_h");
         scan_target_device_addr_msb_h.configure(this);
         scan_target_device_addr_msb_h.build();

         scan_rx_type_h = scan_rx_type::type_id::create("scan_rx_type_h");
         scan_rx_type_h.configure(this);
         scan_rx_type_h.build();

         scan_interval_reg_h = scan_interval_reg::type_id::create("scan_interval_reg_h");
         scan_interval_reg_h.configure(this);
         scan_interval_reg_h.build();

         scan_window_reg_h = scan_window_reg::type_id::create("scan_window_reg_h");
         scan_window_reg_h.configure(this);
         scan_window_reg_h.build();

         init_reg_h = init_reg::type_id::create("init_reg_h");
         init_reg_h.configure(this);
         init_reg_h.build();

         init_source_device_addr_lsb_h = init_source_device_addr_lsb::type_id::create("init_source_device_addr_lsb_h");
         init_source_device_addr_lsb_h.configure(this);
         init_source_device_addr_lsb_h.build();

         init_source_device_addr_msb_h = init_source_device_addr_msb::type_id::create("init_source_device_addr_msb_h");
         init_source_device_addr_msb_h.configure(this);
         init_source_device_addr_msb_h.build();

         init_target_device_addr_lsb_h = init_target_device_addr_lsb::type_id::create("init_target_device_addr_lsb_h");
         init_target_device_addr_lsb_h.configure(this);
         init_target_device_addr_lsb_h.build();

         init_target_device_addr_msb_h = init_target_device_addr_msb::type_id::create("init_target_device_addr_msb_h");
         init_target_device_addr_msb_h.configure(this);
         init_target_device_addr_msb_h.build();

         channel_access_addr_h = channel_access_addr::type_id::create("channel_access_addr_h");
         channel_access_addr_h.configure(this);
         channel_access_addr_h.build();

         CRC_init_value_h = CRC_init_value::type_id::create("CRC_init_value_h");
         CRC_init_value_h.configure(this);
         CRC_init_value_h.build();

         window_size_reg_h = window_size_reg::type_id::create("window_size_reg_h");
         window_size_reg_h.configure(this);
         window_size_reg_h.build();

         window_offset_reg_h = window_offset_reg::type_id::create("window_offset_reg_h");
         window_offset_reg_h.configure(this);
         window_offset_reg_h.build();

         conn_interval_reg_h = conn_interval_reg::type_id::create("conn_interval_reg_h");
         conn_interval_reg_h.configure(this);
         conn_interval_reg_h.build();

         conn_interval_min_reg_h = conn_interval_min_reg::type_id::create("conn_interval_min_reg_h");
         conn_interval_min_reg_h.configure(this);
         conn_interval_min_reg_h.build();

         conn_interval_max_reg_h = conn_interval_max_reg::type_id::create("conn_interval_max_reg_h");
         conn_interval_max_reg_h.configure(this);
         conn_interval_max_reg_h.build();

         latency_reg_h = latency_reg::type_id::create("latency_reg_h");
         latency_reg_h.configure(this);
         latency_reg_h.build();

         sup_timeout_reg_h = sup_timeout_reg::type_id::create("sup_timeout_reg_h");
         sup_timeout_reg_h.configure(this);
         sup_timeout_reg_h.build();

         data_channel_map_reg_lsb_h = data_channel_map_reg_lsb::type_id::create("data_channel_map_reg_lsb_h");
         data_channel_map_reg_lsb_h.configure(this);
         data_channel_map_reg_lsb_h.build();

         data_channel_map_reg_msb_h = data_channel_map_reg_msb::type_id::create("data_channel_map_reg_msb_h");
         data_channel_map_reg_msb_h.configure(this);
         data_channel_map_reg_msb_h.build();

         hop_reg_h = hop_reg::type_id::create("hop_reg_h");
         hop_reg_h.configure(this);
         hop_reg_h.build();

         SCA_h = SCA::type_id::create("SCA_h");
         SCA_h.configure(this);
         SCA_h.build();

         control_pdu_h = control_pdu::type_id::create("control_pdu_h");
         control_pdu_h.configure(this);
         control_pdu_h.build();

         data_pdu_h = data_pdu::type_id::create("data_pdu_h");
         data_pdu_h.configure(this);
         data_pdu_h.build();

         feature_exchange_h = feature_exchange::type_id::create("feature_exchange_h");
         feature_exchange_h.configure(this);
         feature_exchange_h.build();

         encrypt_rand_lsb_h = encrypt_rand_lsb::type_id::create("encrypt_rand_lsb_h");
         encrypt_rand_lsb_h.configure(this);
         encrypt_rand_lsb_h.build();

         encrypt_rand_msb_h = encrypt_rand_msb::type_id::create("encrypt_rand_msb_h");
         encrypt_rand_msb_h.configure(this);
         encrypt_rand_msb_h.build();

         EDIV_h = EDIV::type_id::create("EDIV_h");
         EDIV_h.configure(this);
         EDIV_h.build();

         LTK_0_h = LTK_0::type_id::create("LTK_0_h");
         LTK_0_h.configure(this);
         LTK_0_h.build();

         LTK_1_h = LTK_1::type_id::create("LTK_1_h");
         LTK_1_h.configure(this);
         LTK_1_h.build();

         LTK_2_h = LTK_2::type_id::create("LTK_2_h");
         LTK_2_h.configure(this);
         LTK_2_h.build();

         LTK_3_h = LTK_3::type_id::create("LTK_3_h");
         LTK_3_h.configure(this);
         LTK_3_h.build();

         SKDm_msb_h = SKDm_msb::type_id::create("SKDm_msb_h");
         SKDm_msb_h.configure(this);
         SKDm_msb_h.build();

         SKDm_lsb_h = SKDm_lsb::type_id::create("SKDm_lsb_h");
         SKDm_lsb_h.configure(this);
         SKDm_lsb_h.build();

         Ivm_h = Ivm::type_id::create("Ivm_h");
         Ivm_h.configure(this);
         Ivm_h.build();

         SKDs_msb_h = SKDs_msb::type_id::create("SKDs_msb_h");
         SKDs_msb_h.configure(this);
         SKDs_msb_h.build();

         SKDs_lsb_h = SKDs_lsb::type_id::create("SKDs_lsb_h");
         SKDs_lsb_h.configure(this);
         SKDs_lsb_h.build();

         Ivs_h = IVs::type_id::create("Ivs_h");
         Ivs_h.configure(this);
         Ivs_h.build();

         authenticated_payload_timeout_h = authenticated_payload_timeout::type_id::create("authenticated_payload_timeout_h");
         authenticated_payload_timeout_h.configure(this);
         authenticated_payload_timeout_h.build();

         version_h = version::type_id::create("version_h");
         version_h.configure(this);
         version_h.build();

         company_id_h = company_id::type_id::create("company_id_h");
         company_id_h.configure(this);
         company_id_h.build();

         ISR_h = ISR::type_id::create("ISR_h");
         ISR_h.configure(this);
         ISR_h.build();

         IE_h = IE::type_id::create("IE_h");
         IE_h.configure(this);
         IE_h.build();

         command_reg_h = command_reg::type_id::create("command_reg_h");
         command_reg_h.configure(this);
         command_reg_h.build();

         bt_map = create_map("bt_map", 'h0, 4, UVM_LITTLE_ENDIAN);
         default_map = bt_map;

         bt_map.add_reg(state_register_h, 'h0, "RW");
         bt_map.add_reg(adv_params_h, 'h4, "RW");
         bt_map.add_reg(adv_source_device_addr_lsb_h, 'h8, "RW");
         bt_map.add_reg(adv_source_device_addr_msb_h, 'hc, "RW");
         bt_map.add_reg(adv_interval_reg_h, 'h10, "RW");
         bt_map.add_reg(adv_interval_min_reg_h, 'h14, "RW");
         bt_map.add_reg(adv_interval_max_reg_h, 'h18, "RW");
         bt_map.add_reg(adv_direct_addr_lsb_h, 'h1c, "RW");
         bt_map.add_reg(adv_direct_addr_msb_h, 'h20, "RW");
         bt_map.add_reg(adv_rx_type_h, 'h24, "RW");
         bt_map.add_reg(scan_params_h, 'h28, "RW");
         bt_map.add_reg(scan_source_device_addr_lsb_h, 'h2c, "RW");
         bt_map.add_reg(scan_source_device_addr_msb_h, 'h30, "RW");
         bt_map.add_reg(scan_target_device_addr_lsb_h, 'h34, "RW");
         bt_map.add_reg(scan_target_device_addr_msb_h, 'h38, "RW");
         bt_map.add_reg(scan_rx_type_h, 'h3c, "RW");
         bt_map.add_reg(scan_interval_reg_h, 'h40, "RW");
         bt_map.add_reg(scan_window_reg_h, 'h44, "RW");
         bt_map.add_reg(init_reg_h, 'h48, "RW");
         bt_map.add_reg(init_source_device_addr_lsb_h, 'h4c, "RW");
         bt_map.add_reg(init_source_device_addr_msb_h, 'h50, "RW");
         bt_map.add_reg(init_target_device_addr_lsb_h, 'h54, "RW");
         bt_map.add_reg(init_target_device_addr_msb_h, 'h58, "RW");
         bt_map.add_reg(channel_access_addr_h, 'h5c, "RW");
         bt_map.add_reg(CRC_init_value_h, 'h60, "RW");
         bt_map.add_reg(window_size_reg_h, 'h64, "RW");
         bt_map.add_reg(window_offset_reg_h, 'h68, "RW");
         bt_map.add_reg(conn_interval_reg_h, 'h6c, "RW");
         bt_map.add_reg(conn_interval_min_reg_h, 'h70, "RW");
         bt_map.add_reg(conn_interval_max_reg_h, 'h74, "RW");
         bt_map.add_reg(latency_reg_h, 'h78, "RW");
         bt_map.add_reg(sup_timeout_reg_h, 'h7c, "RW");
         bt_map.add_reg(data_channel_map_reg_lsb_h, 'h80, "RW");
         bt_map.add_reg(data_channel_map_reg_msb_h, 'h84, "RW");
         bt_map.add_reg(hop_reg_h, 'h88, "RW");
         bt_map.add_reg(SCA_h, 'h8c, "RW");
         bt_map.add_reg(control_pdu_h, 'h90, "RW");
         bt_map.add_reg(data_pdu_h, 'h94, "RW");
         bt_map.add_reg(feature_exchange_h, 'h98, "RW");
         bt_map.add_reg(encrypt_rand_lsb_h, 'h9c, "RW");
         bt_map.add_reg(encrypt_rand_msb_h, 'ha0, "RW");
         bt_map.add_reg(EDIV_h, 'ha4, "RW");
         bt_map.add_reg(LTK_0_h, 'ha8, "RW");
         bt_map.add_reg(LTK_1_h, 'hac, "RW");
         bt_map.add_reg(LTK_2_h, 'hb0, "RW");
         bt_map.add_reg(LTK_3_h, 'hb4, "RW");
         bt_map.add_reg(SKDm_msb_h, 'hb8, "RW");
         bt_map.add_reg(SKDm_lsb_h, 'hbc, "RW");
         bt_map.add_reg(Ivm_h, 'hc0, "RW");
         bt_map.add_reg(SKDs_msb_h, 'hc4, "RW");
         bt_map.add_reg(SKDs_lsb_h, 'hc8, "RW");
         bt_map.add_reg(Ivs_h, 'hcc, "RW");
         bt_map.add_reg(authenticated_payload_timeout_h, 'hd0, "RW");
         bt_map.add_reg(version_h, 'hd4, "RW");
         bt_map.add_reg(company_id_h, 'hd8, "RW");
         bt_map.add_reg(ISR_h, 'hdc, "RW");
         bt_map.add_reg(IE_h, 'he0, "RW");
         bt_map.add_reg(command_reg_h, 'he4, "RW");

         lock_model();
      endfunction
   endclass
`include "ble_ral_block.sv"

endpackage
